[
  {
    "id": "",
    "name": "Available HOBOs",
    "body": {
      "content": "<p>To get he HOBO exercises started, you should verify, that enough HOBO records were loaded to the database. Count all rows and alias the result as <strong>HOBOs</strong>.</p>",
      "type": "html"
    },
    "solution": {
      "content": "SELECT count(*) AS \"HOBOs\" FROM metadata",
      "type": "sql"
    }
  },
  {
    "id": "",
    "name": "Available data",
    "body": {
      "content": "<p>Beside the metadata, we will need some raw data recorded and some processed quality checked data. Select each <strong>meta_id</strong> along with two flags: <strong>raw_data_available, data_available</strong>, that indicate wheter related data records are available.</p>",
      "type": "html"
    },
    "solution": {
      "content": "SELECT \n\tid AS meta_id,\n\t(SELECT CASE WHEN count(*) > 0 THEN TRUE ELSE FALSE END FROM raw_data WHERE meta_id=m.id) AS raw_data_available,\n\t(SELECT CASE WHEN count(*) > 0 THEN TRUE ELSE FALSE END FROM data WHERE meta_id=m.id) AS data_available\nFROM metadata m",
      "type": "sql"
    },
    "hint": "<p>You will need two sub-queries for this. A <i>flag</i> is typically a boolean value.</p>"
  },
  {
    "id": "",
    "name": "Available years",
    "body": {
      "content": "<p>Beside data and metadata, we need data originating from two different terms. All terms except the winter term 2020/2021 is spanning measured data across year borders. Therefore we need a lookup table to group metadata by terms. <code>JOIN</code> the <strong>terms</strong> table to the available metadata and reduce the dataset to all terms with available metadata and select the count of HOBOs as <storng>\"HOBOs\"</strong> along with all available information from the <strong>terms</strong> table. Run you query with <code>'explain'</code> enabled.</p>"
    },
    "solution": {
      "content": "SELECT * FROM\n(\n\tSELECT term_id, count(*) AS \"HOBOs\" FROM metadata \n\tGROUP BY term_id\n) AS m\nJOIN terms ON m.term_id=terms.id",
      "type": "sql"
    },
    "hint": "<p>There are at least two possible solutions: Join-then-group or Reduce-then-join. Run your soultion with explain enabled and compare to the other solution.</p>"
  },
  {
    "id": "",
    "name": "Raw data bias",
    "body": {
      "content": "<p>For each of the terms that have raw data as well as quality checked data, we can run a simple, yet powerful analysis. Calculate for each term the average temperature, across all sensors and locations for the raw data and the checked data separately. The difference between the two distributions' location can reveal a systematic bias for any analysis that we would run on the raw data, instead of the quality data.</p><p>Select the terms' <strong>full_name</strong> and join the <code>avg</code> of the related records in the <strong>raw_data</strong> and <strong>data</strong> table, aliased as <strong>avg_raw, avg_data</strong></p>",
      "type": "html"
    },
    "solution": {
      "content": "SELECT raw.full_name, avg_raw, avg_data FROM (\n\tSELECT t.full_name, avg(value) AS avg_raw  FROM raw_data\n\tJOIN metadata m ON m.id=raw_data.meta_id\n\tJOIN terms t ON t.id=m.term_id\n\tWHERE variable_id=1\n\tGROUP BY t.full_name\n) AS raw\nLEFT OUTER JOIN (\n\tSELECT t.full_name, avg(value) AS avg_data  FROM data\n\tJOIN metadata m ON m.id=data.meta_id\n\tJOIN terms t ON t.id=m.term_id\n\tGROUP BY t.full_name\n) AS data ON raw.full_name=data.full_name",
      "type": "sql",
      "prefill": "SELECT raw.full_name, avg_raw, avg_data FROM (\n\t-- PUT YOUR raw_data query HERE\n) AS raw\nLEFT OUTER JOIN (\n\t-- PUT YOUR data query HERE\n) AS data ON raw.full_name=data.full_name"
    },
    "hint": "<p>Decompose this into two separated queries in the console and run each of them separatedly.</p>"
  }
]
